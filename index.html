<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>J/place xD 8000√ó8000 Pixel Canvas</title>
<style>
  html, body {
    overscroll-behavior: none;
    touch-action: none;
    height: 100%;
    margin: 0;
    font-family: Arial, sans-serif;
  }
  #topbar {
    height: 48px;
    background: #111;
    color: #fff;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 6px 12px;
  }
  #canvasWrap {
    position: relative;
    height: calc(100% - 48px);
    overflow: hidden;
    background: #fff;
  }
  canvas {
    display: block;
    transform-origin: 0 0;
    cursor: crosshair;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  #colorPicker {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  #coords { color: #ccc; font-size: 13px; margin-left: 20px; }
  #info { color: #ddd; font-size: 13px; margin-left: auto; }
  #cooldown {
    color: #ffcc00;
    font-size: 14px;
    margin-left: 15px;
    min-width: 140px;
  }
  button {
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
  }

  /* Cookie Banner */
  #cookieBanner {
    position: fixed;
    left: 16px;
    right: 16px;
    bottom: 16px;
    background: rgba(18,18,18,0.96);
    color: #fff;
    border-radius: 8px;
    padding: 18px;
    display: flex;
    gap: 12px;
    align-items: center;
    z-index: 10000;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  }
  #cookieBanner p { margin: 0; flex: 1; font-size: 14px; color: #ddd; }
  #cookieBanner .cb-actions { display:flex; gap:10px; align-items:center; }

  /* Modal overlay for captcha */
  .modalOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10010;
  }
  .modal {
    background: #fff;
    color: #000;
    border-radius: 8px;
    padding: 16px;
    width: 380px;
    max-width: calc(100% - 40px);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  }
  .captcha-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    margin: 8px 0 12px 0;
  }
  .captcha-cell {
    background: #f3f3f3;
    height: 90px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    cursor:pointer;
    user-select:none;
    border: 2px solid transparent;
  }
  .captcha-cell.selected { border-color: #2a9df4; box-shadow: 0 3px 8px rgba(42,157,244,0.25); }
  .captcha-controls { display:flex; justify-content:space-between; gap:8px; align-items:center; }
  .smallBtn { padding:6px 8px; border-radius:6px; background:#eee; cursor:pointer; border:1px solid #ccc; }
  .captcha-hint { font-weight:600; margin-bottom:6px; }

  /* responsive tweaks */
  @media (max-width:420px) {
    #cookieBanner { left: 8px; right: 8px; bottom: 8px; padding: 12px; }
    .modal { width: 320px; }
  }
</style>
</head>
<body>
  <div id="topbar">
    <strong>J/placeüôÇ (8000√ó8000)</strong>
    <input type="color" id="colorPicker" value="#ff0000" title="Farbe w√§hlen" />
    <div>Brush: <span id="brushSize">1</span></div>
    <input id="brushRange" type="range" min="1" max="20" value="1" />
    <button id="undoBtn">Undo</button>
    <div id="cooldown">Ready!</div>
    <div id="coords">x:0 y:0</div>
    <div id="info">Zoom: <span id="zoomDisp">1√ó</span></div>
  </div>

  <div id="canvasWrap"><canvas id="viewCanvas"></canvas></div>

  <!-- Cookie Banner -->
  <div id="cookieBanner" style="display:none">
    <p>
      Diese Seite verwendet Cookies & Tracking zur Verbesserung und Analyse. Du kannst "Alle akzeptieren" w√§hlen
      oder nur notwendige Cookies aktivieren. Tracking (z.B. Analyse) wird nur bei Zustimmung aktiviert.
    </p>
    <div class="cb-actions">
      <button id="acceptNecessary" class="smallBtn">Nur notwendige</button>
      <button id="acceptAll" style="background:#2a9df4;color:#fff;border:none;border-radius:6px;padding:8px 12px;">Alle akzeptieren</button>
    </div>
  </div>

  <!-- Captcha Modal -->
  <div id="captchaOverlay" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="captchaTitle">
      <div id="captchaTitle" class="captcha-hint">Bitte Aufgabe l√∂sen</div>
      <div id="captchaInstruction" style="font-size:14px;color:#444;margin-bottom:6px;"></div>
      <div class="captcha-grid" id="captchaGrid"></div>
      <div class="captcha-controls">
        <div>
          <button id="captchaReload" class="smallBtn">Neuer Versuch</button>
          <button id="captchaCancel" class="smallBtn">Abbrechen</button>
        </div>
        <div>
          <button id="captchaVerify" style="background:#2a9df4;color:#fff;border:none;border-radius:6px;padding:6px 10px;">√úberpr√ºfen</button>
        </div>
      </div>
      <div id="captchaMessage" style="margin-top:8px;color:#b00;min-height:18px;font-size:13px;"></div>
    </div>
  </div>

<script type="module">
/* ===== Firebase Config ===== */
const firebaseConfig = {
  apiKey: "AIzaSyDm1K1l_9vzjcbrCtoUEgM3z2c-gvmcBbU",
  authDomain: "papergame-24427.firebaseapp.com",
  projectId: "papergame-24427",
  storageBucket: "papergame-24427.firebasestorage.app",
  messagingSenderId: "44002603651",
  appId: "1:44002603651:web:090bf8b799b364e16ce1b6"
};
/* =========================== */

/* ===== Firebase imports (inkl. addDoc/collection f√ºr Tracking) ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp, collection, addDoc } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

/* ===== Grundwerte ===== */
const TILE_SIZE = 64;
const CANVAS_SIZE = 8000;
const TILE_COUNT = Math.ceil(CANVAS_SIZE / TILE_SIZE);
const LOCAL_COOLDOWN_MS = 5000;

/* ===== Firebase Init ===== */
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
let user = null;
await signInAnonymously(auth).then(u => user = u.user).catch(e => console.warn("Auth failed:", e));

/* ===== Consent & Tracking ===== */
let cookieConsent = localStorage.getItem('cookieConsent') || null;
const cookieBanner = document.getElementById('cookieBanner');
const acceptAllBtn = document.getElementById('acceptAll');
const acceptNecessaryBtn = document.getElementById('acceptNecessary');

function showCookieBannerIfNeeded() {
  if (!cookieConsent) cookieBanner.style.display = 'flex';
}
showCookieBannerIfNeeded();

acceptAllBtn.addEventListener('click', async () => {
  localStorage.setItem('cookieConsent', 'all');
  cookieConsent = 'all';
  cookieBanner.style.display = 'none';
  initTracking();
  await sendTrackingEvent('cookie_consent', { choice: 'all' });
});
acceptNecessaryBtn.addEventListener('click', async () => {
  localStorage.setItem('cookieConsent', 'necessary');
  cookieConsent = 'necessary';
  cookieBanner.style.display = 'none';
  await sendTrackingEvent('cookie_consent', { choice: 'necessary' });
});

/* Tracking helper: schreibt nur, wenn cookieConsent === 'all' */
let trackingEnabled = false;
function initTracking() {
  trackingEnabled = true;
  // optional: any initialization for external services would go here
}

/**
 * sendTrackingEvent(eventName, payload)
 * schreibt in Firestore collection "tracking" wenn Einwilligung vorliegt.
 */
async function sendTrackingEvent(eventName, payload = {}) {
  try {
    if (cookieConsent !== 'all') return; // nur mit Einwilligung
    const docRef = await addDoc(collection(db, "tracking"), {
      event: eventName,
      payload,
      uid: user ? user.uid : null,
      ts: serverTimestamp()
    });
    // console.log("tracked", eventName, "->", docRef.id);
  } catch (e) {
    console.warn("Tracking failed:", e);
  }
}

/* Wenn der Benutzer bereits zugestimmt hatte, aktivieren wir Tracking beim Laden */
if (cookieConsent === 'all') initTracking();

/* ===== UI ===== */
const colorPicker = document.getElementById('colorPicker');
let color = colorPicker.value;
colorPicker.addEventListener('input', () => color = colorPicker.value);
const brushRange = document.getElementById('brushRange');
const brushSizeDisp = document.getElementById('brushSize');
brushRange.addEventListener('input', () => brushSizeDisp.textContent = brushRange.value);
const cooldownEl = document.getElementById('cooldown');

const viewCanvas = document.getElementById('viewCanvas');
const ctx = viewCanvas.getContext('2d', { alpha: false });
ctx.imageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;

let viewW = window.innerWidth, viewH = window.innerHeight - 48;
viewCanvas.width = viewW;
viewCanvas.height = viewH;

let scale = 1, offsetX = 0, offsetY = 0;
document.getElementById('zoomDisp').textContent = scale + '√ó';

/* ===== Resize ===== */
window.addEventListener('resize', () => {
  viewW = window.innerWidth; viewH = window.innerHeight - 48;
  viewCanvas.width = viewW; viewCanvas.height = viewH; redrawViewport();
});

/* ===== Panning & Zoom ===== */
let isPanning = false, lastPanX = 0, lastPanY = 0;
viewCanvas.addEventListener('mousedown', e => {
  if (e.button === 1 || e.ctrlKey) { isPanning = true; lastPanX = e.clientX; lastPanY = e.clientY; return; }
  drawFromPointer(e);
});
window.addEventListener('mousemove', e => {
  if (isPanning) {
    const dx = (e.clientX - lastPanX) / scale;
    const dy = (e.clientY - lastPanY) / scale;
    offsetX -= dx; offsetY -= dy;
    lastPanX = e.clientX; lastPanY = e.clientY;
    clampOffset(); redrawViewport();
  }
});
window.addEventListener('mouseup', () => isPanning = false);

viewCanvas.addEventListener('mousemove', e => {
  const rect = viewCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const wx = Math.floor(offsetX + mx / scale), wy = Math.floor(offsetY + my / scale);
  document.getElementById('coords').textContent = `x:${wx} y:${wy}`;
});

viewCanvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldScale = scale;
  scale *= (e.deltaY < 0) ? 1.1 : 0.9;
  scale = Math.min(Math.max(scale, 0.1), 40);
  const mx = e.clientX, my = e.clientY - 48;
  const worldX = offsetX + mx / oldScale, worldY = offsetY + my / oldScale;
  offsetX = worldX - mx / scale; offsetY = worldY - my / scale;
  clampOffset(); redrawViewport();
  document.getElementById('zoomDisp').textContent = scale.toFixed(2) + '√ó';
}, { passive: false });

/* ===== Touch Gestures ===== */
let lastTouchDistance = 0, lastMidX = 0, lastMidY = 0;
viewCanvas.addEventListener('touchmove', e => {
  if (e.touches.length === 2) {
    e.preventDefault();
    const [t1, t2] = e.touches;
    const dx = t2.clientX - t1.clientX, dy = t2.clientY - t1.clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const midX = (t1.clientX + t2.clientX) / 2;
    const midY = (t1.clientY + t2.clientY) / 2 - 48;
    if (lastTouchDistance === 0) { lastTouchDistance = dist; lastMidX = midX; lastMidY = midY; return; }
    const zoomFactor = dist / lastTouchDistance;
    if (Math.abs(zoomFactor - 1) > 0.02) {
      const oldScale = scale;
      scale *= zoomFactor; scale = Math.min(Math.max(scale, 0.1), 40);
      const worldX = offsetX + midX / oldScale, worldY = offsetY + midY / oldScale;
      offsetX = worldX - midX / scale; offsetY = worldY - midY / scale;
    } else {
      const moveX = (lastMidX - midX) / scale, moveY = (lastMidY - midY) / scale;
      offsetX += moveX; offsetY += moveY;
    }
    clampOffset(); redrawViewport();
    document.getElementById('zoomDisp').textContent = scale.toFixed(2) + '√ó';
    lastTouchDistance = dist; lastMidX = midX; lastMidY = midY;
  }
}, { passive: false });
viewCanvas.addEventListener('touchend', () => { lastTouchDistance = 0; });

function clampOffset() {
  offsetX = Math.max(0, Math.min(offsetX, CANVAS_SIZE - viewW / scale));
  offsetY = Math.max(0, Math.min(offsetY, CANVAS_SIZE - viewH / scale));
}

/* ===== Firestore Tile Handling ===== */
const tileCache = new Map(), tileListeners = new Map();
let lastPutTime = 0;

function worldToTileCoords(wx, wy) { return { tx: Math.floor(wx / TILE_SIZE), ty: Math.floor(wy / TILE_SIZE) }; }
function tileKey(tx, ty) { return `${tx}_${ty}`; }

function updateTileListeners() {
  const x0 = Math.floor(offsetX / TILE_SIZE), y0 = Math.floor(offsetY / TILE_SIZE);
  const x1 = Math.floor((offsetX + viewW / scale) / TILE_SIZE);
  const y1 = Math.floor((offsetY + viewH / scale) / TILE_SIZE);
  const pad = 1, wanted = new Set();
  for (let tx = Math.max(0, x0 - pad); tx <= Math.min(TILE_COUNT - 1, x1 + pad); tx++) {
    for (let ty = Math.max(0, y0 - pad); ty <= Math.min(TILE_COUNT - 1, y1 + pad); ty++) {
      wanted.add(tileKey(tx, ty));
      if (!tileListeners.has(tileKey(tx, ty))) attachTileListener(tx, ty);
    }
  }
  for (const k of Array.from(tileListeners.keys())) {
    if (!wanted.has(k)) { const u = tileListeners.get(k); if (u) u(); tileListeners.delete(k); }
  }
}

function attachTileListener(tx, ty) {
  const id = tileKey(tx, ty), ref = doc(db, "tiles", id);
  const unsub = onSnapshot(ref, snap => {
    if (!snap.exists()) { tileCache.set(id, null); redrawViewport(); return; }
    const d = snap.data();
    if (d && d.png) {
      const img = new Image();
      img.onload = () => { tileCache.set(id, img); redrawViewport(); };
      img.src = d.png;
    }
  });
  tileListeners.set(id, unsub);
}

/* ===== Rendering ===== */
function redrawViewport() {
  ctx.clearRect(0, 0, viewW, viewH);
  ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, viewW, viewH);
  ctx.imageSmoothingEnabled = false;
  const x0 = Math.floor(offsetX / TILE_SIZE), y0 = Math.floor(offsetY / TILE_SIZE);
  const x1 = Math.floor((offsetX + viewW / scale) / TILE_SIZE);
  const y1 = Math.floor((offsetY + viewH / scale) / TILE_SIZE);
  for (let tx = Math.max(0, x0 - 1); tx <= Math.min(TILE_COUNT - 1, x1 + 1); tx++) {
    for (let ty = Math.max(0, y0 - 1); ty <= Math.min(TILE_COUNT - 1, y1 + 1); ty++) {
      const id = tileKey(tx, ty), img = tileCache.get(id);
      const worldX = tx * TILE_SIZE, worldY = ty * TILE_SIZE;
      const screenX = Math.floor((worldX - offsetX) * scale);
      const screenY = Math.floor((worldY - offsetY) * scale);
      const screenSize = Math.ceil(TILE_SIZE * scale);
      if (img instanceof HTMLImageElement) {
        ctx.drawImage(img, 0, 0, img.width, img.height, screenX, screenY, screenSize, screenSize);
      }
    }
  }

  // Gitter ab Zoom > 15
  if (scale >= 15) {
    const pixelSize = scale;
    const startX = -Math.floor(offsetX % 1 * scale);
    const startY = -Math.floor(offsetY % 1 * scale);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 0.5;
    for (let x = startX; x < viewW; x += pixelSize) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, viewH); ctx.stroke();
    }
    for (let y = startY; y < viewH; y += pixelSize) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(viewW, y); ctx.stroke();
    }
  }
}

/* ===== Pixel setzen ===== */
const undoStack = [];
document.getElementById('undoBtn').addEventListener('click', () => {
  if (undoStack.length === 0) return;
  const last = undoStack.pop();
  applyPutToTileDoc(last.tx, last.ty, last.pngData);
});

/* ===== Captcha Implementation (clientseitig, Bildauswahl) ===== */

/*
  - clientseitiges Bild-Captcha mit SVG-Icons (Auto, Zebrastreifen, Treppe)
  - 3x3 Grid, Zielkategorie wird zuf√§llig gew√§hlt
  - Benutzer klickt Zellen an, "√úberpr√ºfen" validiert
*/

const captchaOverlay = document.getElementById('captchaOverlay');
const captchaGrid = document.getElementById('captchaGrid');
const captchaInstruction = document.getElementById('captchaInstruction');
const captchaReload = document.getElementById('captchaReload');
const captchaVerify = document.getElementById('captchaVerify');
const captchaCancel = document.getElementById('captchaCancel');
const captchaMessage = document.getElementById('captchaMessage');
const captchaTitle = document.getElementById('captchaTitle');

const ICONS = {
  'Auto': `<svg viewBox="0 0 24 24" width="64" height="64" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="7" width="20" height="7" rx="2" fill="#444"/><circle cx="7" cy="17" r="2" fill="#222"/><circle cx="17" cy="17" r="2" fill="#222"/></svg>`,
  'Zebrastreifen': `<svg viewBox="0 0 24 24" width="64" height="64" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="6" width="20" height="3" fill="#444"/><rect x="2" y="10" width="20" height="3" fill="#eee"/><rect x="2" y="14" width="20" height="3" fill="#444"/></svg>`,
  'Treppe': `<svg viewBox="0 0 24 24" width="64" height="64" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="20" height="2" fill="#444"/><rect x="2" y="12" width="14" height="2" fill="#666"/><rect x="2" y="8" width="8" height="2" fill="#888"/></svg>`
};

function makeSVGDataURI(svg) {
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function randomInt(max) { return Math.floor(Math.random() * max); }

/**
 * showImageCaptcha()
 * zeigt das modal und gibt ein Promise zur√ºck, das true/false liefert
 */
function showImageCaptcha() {
  return new Promise((resolve) => {
    // build challenge
    const types = Object.keys(ICONS);
    const target = types[randomInt(types.length)]; // z.B. 'Auto'
    captchaInstruction.textContent = `Klicke alle Felder mit "${target}" an.`;
    captchaMessage.textContent = '';
    captchaTitle.textContent = 'Sicherheits√ºberpr√ºfung';

    // prepare grid
    const cells = [];
    const targetCount = 2 + randomInt(3); // 2..4 targets
    const targetPositions = new Set();
    while (targetPositions.size < targetCount) targetPositions.add(randomInt(9));
    captchaGrid.innerHTML = '';

    // Fill grid with icons; some cells will be target, others random other icons
    for (let i = 0; i < 9; i++) {
      const cell = document.createElement('div');
      cell.className = 'captcha-cell';
      const isTarget = targetPositions.has(i);
      // choose icon: if target -> target icon, else random other icon (could by chance be same; that's okay small variability)
      let iconKey = isTarget ? target : types.filter(t => t !== target)[randomInt(types.length - 1)];
      const img = document.createElement('div');
      img.innerHTML = ICONS[iconKey];
      // set data attributes
      cell.dataset.type = iconKey;
      cell.dataset.index = i.toString();
      cell.appendChild(img);
      cell.addEventListener('click', () => {
        cell.classList.toggle('selected');
      });
      captchaGrid.appendChild(cell);
      cells.push(cell);
    }

    // show overlay
    captchaOverlay.style.display = 'flex';
    captchaOverlay.setAttribute('aria-hidden', 'false');

    // handlers
    function cleanup(result) {
      captchaOverlay.style.display = 'none';
      captchaOverlay.setAttribute('aria-hidden', 'true');
      captchaReload.removeEventListener('click', onReload);
      captchaVerify.removeEventListener('click', onVerify);
      captchaCancel.removeEventListener('click', onCancel);
      resolve(result);
    }

    function onReload() {
      // rebuild challenge
      showImageCaptcha().then(r => cleanup(r));
      // remove listeners of this invocation
      captchaReload.removeEventListener('click', onReload);
      captchaVerify.removeEventListener('click', onVerify);
      captchaCancel.removeEventListener('click', onCancel);
    }

    function onVerify() {
      // compute selected indices and actual target indices
      const selected = [];
      const actualTargets = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (c.classList.contains('selected')) selected.push(i);
        if (c.dataset.type === target) actualTargets.push(i);
      }
      // sort & compare
      const sSorted = selected.slice().sort((a,b)=>a-b);
      const aSorted = actualTargets.slice().sort((a,b)=>a-b);
      const equal = (sSorted.length === aSorted.length) && sSorted.every((v,i)=>v===aSorted[i]);
      if (equal) {
        captchaMessage.style.color = "#0a0";
        captchaMessage.textContent = "Erfolgreich ‚Äî danke!";
        sendTrackingEvent('captcha_passed', { target });
        cleanup(true);
      } else {
        captchaMessage.style.color = "#b00";
        captchaMessage.textContent = "Falsche Auswahl. Bitte versuche es erneut.";
        sendTrackingEvent('captcha_failed', { target });
      }
    }

    function onCancel() {
      captchaMessage.style.color = "#b00";
      captchaMessage.textContent = "Abgebrochen.";
      sendTrackingEvent('captcha_cancelled', { target });
      cleanup(false);
    }

    captchaReload.addEventListener('click', onReload);
    captchaVerify.addEventListener('click', onVerify);
    captchaCancel.addEventListener('click', onCancel);

    // Also track that we showed the captcha (will write only when consent is given)
    sendTrackingEvent('captcha_shown', { target });
  });
}

/* ===== Integration: 1% Chance f√ºr Captcha beim Pixel-Setzen ===== */

async function maybeRequireCaptcha() {
  // 1% chance
  const roll = Math.random();
  if (roll < 0.01) {
    // show captcha and await result
    const ok = await showImageCaptcha();
    if (!ok) return false; // user failed or cancelled
    return true;
  }
  return true; // no captcha required
}

/* ===== Pixel set pipeline (√§ndert drawFromPointer leicht) ===== */

async function drawFromPointer(e) {
  const r = viewCanvas.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  const wx = offsetX + mx / scale, wy = offsetY + my / scale;
  const b = parseInt(brushRange.value), half = Math.floor(b / 2);
  const px = Math.floor(wx) - half, py = Math.floor(wy) - half;

  // Before we start modifying tiles: maybe require captcha (1% chance)
  const captchaOk = await maybeRequireCaptcha();
  if (!captchaOk) {
    // abort placing pixels
    return;
  }

  for (let dx = 0; dx < b; dx++)
    for (let dy = 0; dy < b; dy++) {
      const wx2 = px + dx, wy2 = py + dy;
      if (wx2 < 0 || wy2 < 0 || wx2 >= CANVAS_SIZE || wy2 >= CANVAS_SIZE) continue;
      const { tx, ty } = worldToTileCoords(wx2, wy2);
      await putPixelToTile(tx, ty, wx2 - tx * TILE_SIZE, wy2 - ty * TILE_SIZE, color);
      // send tracking event for pixel (only if consent given)
      await sendTrackingEvent('pixel_placed', { tx, ty, localX: wx2 - tx * TILE_SIZE, localY: wy2 - ty * TILE_SIZE, color });
    }
}

async function loadTileCanvas(tx, ty) {
  const id = tileKey(tx, ty), ref = doc(db, "tiles", id);
  const snap = await getDoc(ref);
  const off = document.createElement('canvas');
  off.width = TILE_SIZE; off.height = TILE_SIZE;
  const offCtx = off.getContext('2d');
  offCtx.imageSmoothingEnabled = false;
  if (snap.exists() && snap.data().png) {
    const img = new Image();
    await new Promise(res => { img.onload = () => { offCtx.drawImage(img, 0, 0, TILE_SIZE, TILE_SIZE); res(); }; img.src = snap.data().png; });
  }
  return { off, offCtx };
}

async function putPixelToTile(tx, ty, localX, localY, hexColor) {
  const now = Date.now();
  if (now - lastPutTime < LOCAL_COOLDOWN_MS) return;
  lastPutTime = now;

  const { off, offCtx } = await loadTileCanvas(tx, ty);
  const prev = off.toDataURL(); undoStack.push({ tx, ty, pngData: prev });
  const imgd = offCtx.getImageData(0, 0, TILE_SIZE, TILE_SIZE);
  const idx = (Math.floor(localY) * TILE_SIZE + Math.floor(localX)) * 4;
  const rgba = hexToRgba(hexColor);
  imgd.data[idx] = rgba.r; imgd.data[idx + 1] = rgba.g; imgd.data[idx + 2] = rgba.b; imgd.data[idx + 3] = rgba.a;
  offCtx.putImageData(imgd, 0, 0);
  const png = off.toDataURL("image/png");
  await applyPutToTileDoc(tx, ty, png);
}

function hexToRgba(hex) {
  const h = hex.replace('#', '');
  return {
    r: parseInt(h.substr(0, 2), 16),
    g: parseInt(h.substr(2, 2), 16),
    b: parseInt(h.substr(4, 2), 16),
    a: 255
  };
}

async function applyPutToTileDoc(tx, ty, png) {
  const id = tileKey(tx, ty);
  await setDoc(doc(db, "tiles", id), { png, updatedAt: serverTimestamp(), authorUid: user ? user.uid : null }, { merge: true });
  const img = new Image(); img.src = png; tileCache.set(id, img); redrawViewport();
}

/* ===== Cooldown-Timer-Anzeige ===== */
setInterval(() => {
  const now = Date.now();
  const remaining = (LOCAL_COOLDOWN_MS - (now - lastPutTime)) / 1000;
  if (remaining > 0) {
    cooldownEl.textContent = `Next pixel in: ${remaining.toFixed(1)}s`;
    cooldownEl.style.color = "#ff6666";
  } else {
    cooldownEl.textContent = "Ready!";
    cooldownEl.style.color = "#00ff88";
  }
}, 200);

/* ===== Start ===== */
offsetX = (CANVAS_SIZE - viewW) / 2;
offsetY = (CANVAS_SIZE - viewH) / 2;
clampOffset();
updateTileListeners();
redrawViewport();
setInterval(() => updateTileListeners(), 200);
viewCanvas.addEventListener('click', e => drawFromPointer(e));

</script>
</body>
</html>
