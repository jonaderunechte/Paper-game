<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blackjack Circle — Hotseat (GitHub Pages)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg: #0b3b2e;
    --felt:#0e552f;
    --panel: rgba(0,0,0,0.18);
    --accent:#ffd166;
    --muted:#cfeee4;
    --card-white:#fff;
    --shadow: 0 12px 30px rgba(0,0,0,0.6);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--muted)}
  body{
    background: radial-gradient(circle at 10% 10%, rgba(0,0,0,0.15), transparent 20%), linear-gradient(#031b14,#042a1f);
    display:flex;align-items:center;justify-content:center;padding:16px;
    min-height:100vh;
  }

  /* App wrapper */
  .app{
    width:100%; max-width:1400px; height:calc(100vh - 32px); border-radius:12px; overflow:hidden; box-shadow:var(--shadow);
    display:grid; grid-template-columns: 360px 1fr; gap:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }
  @media (max-width:980px){ .app{ grid-template-columns: 1fr; } }

  /* Sidebar (Setup) */
  aside.sidebar{
    padding:14px; background: rgba(0,0,0,0.14); display:flex; flex-direction:column; gap:10px;
  }
  .brand{ display:flex; align-items:center; gap:12px; }
  .logo{ width:56px;height:56px;border-radius:10px; background:linear-gradient(135deg,var(--accent),#ff9f1c); display:flex;align-items:center;justify-content:center;font-weight:800;color:#091; }
  h1{ margin:0; font-size:1.05rem; color:var(--accent) }
  label{ font-size:0.9rem; color:#bfeee1; display:block; margin-bottom:6px; }
  input[type="text"], input[type="number"], select { width:100%; padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.05); background:transparent; color:var(--muted) }
  .players-config{ display:flex; flex-direction:column; gap:8px; max-height:46vh; overflow:auto; padding-right:6px; }
  .player-row{ display:flex; gap:8px; align-items:center; background: rgba(0,0,0,0.08); padding:8px; border-radius:8px; }
  .btn{ padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; }
  .btn.primary{ background:linear-gradient(90deg,var(--accent),#ff9f1c); color:#041212; }
  .btn.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); }

  /* Board (takes most space) */
  .board-wrap{ position:relative; padding:12px; display:flex; flex-direction:column; gap:12px; }
  .board{
    flex:1; border-radius:10px; background: radial-gradient(circle at center, rgba(0,0,0,0.08), transparent 30%), linear-gradient(180deg,var(--felt), #06321f);
    position:relative; overflow:hidden; display:flex; align-items:center; justify-content:center;
  }
  /* Fullscreen mode when game running */
  .board.fullscreen{
    position:fixed; top:0; left:0; right:0; bottom:0; z-index:60; margin:0; border-radius:0; padding:20px;
  }

  /* circular table area */
  .table-circle {
    width:88vmin; height:88vmin; max-width:920px; max-height:920px; border-radius:50%; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
    display:block; position:relative; box-shadow: inset 0 6px 20px rgba(0,0,0,0.4);
  }
  .felt {
    position:absolute; inset:6%; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.02), transparent), linear-gradient(180deg,#0b5e3f,#044a30);
    display:flex; align-items:center; justify-content:center;
  }

  /* Dealer in center */
  .dealer {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:28%; height:20%;
    display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px;
    pointer-events:none;
  }
  .dealer .small-hand{ display:flex; gap:8px; align-items:center; pointer-events:none; }
  .dealer .label { font-weight:800; color:var(--accent); font-size:1.05rem; text-align:center; pointer-events:none; }

  /* Player positions arranged dynamically */
  .player-slot {
    position:absolute; transform-origin:center center; display:flex; flex-direction:column; align-items:center; gap:8px;
    width:20%; min-width:120px; pointer-events:auto;
  }
  .player-name{ font-weight:800; color:var(--accent); text-align:center; }
  .player-balance{ font-size:0.85rem; color:#cfeee4; }
  .player-hand { display:flex; gap:8px; align-items:center; justify-content:center; }

  /* current player emphasis */
  .player-slot.current .card { transform: scale(1.15) translateY(-6px); box-shadow: 0 20px 50px rgba(0,0,0,0.6); }
  .player-slot.current .player-name{ color:#fff; text-shadow:0 4px 20px rgba(0,0,0,0.6); }

  /* Cards */
  .card {
    width:84px; height:120px; border-radius:10px; background:var(--card-white); color:#000; display:flex; flex-direction:column; padding:8px; justify-content:space-between;
    box-shadow:0 8px 20px rgba(0,0,0,0.5); transition: transform 220ms cubic-bezier(.2,.9,.3,1), box-shadow 220ms;
    user-select:none;
  }
  .card.red .rank, .card.red .suit { color:#b30d0d; }
  .card .rank{ font-weight:800; }
  .card .suit{ font-size:1.6rem; text-align:center; }
  .card.hidden { background-image: var(--card-back); background-size:cover; background-position:center; border: 1px solid rgba(0,0,0,0.25); color:transparent; display:block; }

  /* animation to deal card from deck center */
  .deal-anim { animation:dealMove 500ms ease forwards; }
  @keyframes dealMove {
    from { transform: translate(0,0) scale(0.2) rotate(-20deg); opacity:0; }
    to { transform: translate(0,0) scale(1) rotate(0); opacity:1; }
  }

  /* chips */
  .chips { display:flex; gap:8px; align-items:center; }
  .chip {
    width:46px; height:46px; border-radius:50%; background:linear-gradient(180deg,#fff,#ddd); display:flex;align-items:center;justify-content:center;font-weight:900;
    box-shadow: 0 8px 22px rgba(0,0,0,0.45); cursor:pointer; transition: transform 180ms;
  }
  .chip:active{ transform:translateY(4px); }

  /* actions floating panel */
  .actions-panel {
    position: absolute; bottom:6%; left:50%; transform:translateX(-50%); display:flex; gap:8px; z-index:50;
    background:rgba(0,0,0,0.24); padding:8px 12px; border-radius:10px;
  }
  .actions-panel button { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:800; }

  /* small UI elements */
  .topbar{ display:flex; justify-content:space-between; align-items:center; gap:8px; padding:6px 12px; }
  .log { max-height:120px; overflow:auto; padding:10px; background:rgba(0,0,0,0.18); border-radius:8px; color:#dfffe9; }

  /* hide sidebar when fullscreen */
  .hide-sidebar{ display:none !important; }

  /* responsive tweaks */
  @media (max-width:800px){
    .player-slot { width:28%; min-width:90px; }
    .card{ width:64px; height:96px; }
    .dealer { width:36%; height:18%; }
    .table-circle{ width:96vmin; height:96vmin; }
    .actions-panel{ bottom:3%; flex-wrap:wrap; }
  }

</style>
</head>
<body>
<div class="app" id="app">
  <!-- SIDEBAR / SETUP -->
  <aside class="sidebar" id="sidebar">
    <div class="brand">
      <div class="logo">BJ</div>
      <div>
        <h1>Blackjack — Circle</h1>
        <div style="font-size:0.9rem;color:#bfeee1">Hotseat · Responsive · GitHub Pages</div>
      </div>
    </div>

    <label>Spieler</label>
    <div style="display:flex; gap:8px;">
      <input type="number" id="numPlayers" min="1" max="7" value="3" />
      <select id="botRate">
        <option value="0">0 Bots</option>
        <option value="1">1 Bot</option>
        <option value="2">2 Bots</option>
      </select>
    </div>

    <label>Kartendesign (Rückseite PNG-URL)</label>
    <input type="text" id="cardBackInput" placeholder="Raw GitHub URL zur card-back.png" />

    <label>Startguthaben pro Spieler (€)</label>
    <input type="number" id="startBank" min="0" value="1000" />

    <label>Start-Chip (Auswahl für Einsätze)</label>
    <select id="startChip">
      <option value="10">10</option>
      <option value="25" selected>25</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>

    <div style="display:flex; gap:8px; margin-top:8px;">
      <button class="btn primary" id="setupBtn">Setup erzeugen</button>
      <button class="btn ghost" id="startBtn">Spiel starten</button>
    </div>

    <label style="margin-top:8px">Spieler Konfiguration</label>
    <div class="players-config" id="playersConfig">
      <!-- dynamically filled -->
    </div>

    <label style="margin-top:6px">Sounds</label>
    <div style="display:flex;gap:8px;">
      <button class="btn ghost" id="muteBtn">Stumm</button>
      <button class="btn ghost" id="sampleSounds">Sounds testen</button>
    </div>

    <div style="margin-top:auto;">
      <div style="font-size:0.85rem;color:#bfeee1">Hinweis: Dies ist Hotseat (kein Server). Kartenrückseite: PNG -> Raw GitHub URL.</div>
    </div>
  </aside>

  <!-- BOARD -->
  <main class="board-wrap">
    <div class="topbar">
      <div id="status">Bereit</div>
      <div style="display:flex;gap:8px;align-items:center">
        <div id="balances" style="font-weight:700"></div>
        <button class="btn ghost" id="dealBtn" disabled>Geben</button>
        <button class="btn ghost" id="nextBtn" disabled>Nächster</button>
      </div>
    </div>

    <section class="board" id="board">
      <div class="table-circle" id="tableCircle">
        <div class="felt" id="felt">
          <!-- Dealer center -->
          <div class="dealer" id="dealer">
            <div class="label">Dealer</div>
            <div class="small-hand" id="dealerHand"></div>
            <div style="font-size:0.95rem;color:#dfffe9" id="dealerVal"></div>
          </div>

          <!-- player slots inserted here -->
        </div>
      </div>

      <!-- action controls (bottom) -->
      <div class="actions-panel" id="actionsPanel">
        <div style="display:flex;align-items:center;gap:8px;">
          <div class="chips" id="chipPicker">
            <div class="chip" data-value="10">10</div>
            <div class="chip" data-value="25">25</div>
            <div class="chip" data-value="50">50</div>
            <div class="chip" data-value="100">100</div>
          </div>
        </div>
        <div style="display:flex;gap:8px;">
          <button class="btn" id="hitBtn" style="background:#06d6a0">Hit</button>
          <button class="btn" id="standBtn" style="background:var(--accent)">Stand</button>
          <button class="btn" id="doubleBtn" style="background:#f97316;color:white">Double</button>
          <button class="btn" id="splitBtn" style="background:#6b21a8;color:white">Split</button>
          <button class="btn" id="insureBtn" style="background:#0ea5a4;color:white">Insurance</button>
        </div>
      </div>

      <div style="position:absolute; right:12px; bottom:12px; width:320px;">
        <div class="log" id="log"></div>
      </div>
    </section>
  </main>
</div>

<script>
/* Blackjack Circle — Single file
   - Hotseat multiplayer
   - Players arranged circularly
   - CSS cards + PNG back (user-supplied)
   - Animations + sounds (configurable)
*/

/* ========== CONFIG (user: set CARD_BACK_URL to raw github URL after upload) ========== */
let CARD_BACK_URL = ''; // default blank - user should paste raw GitHub URL via input in UI
// default sample sounds (you can change to myinstants links or your own hosted files)
const SOUND = {
  card: 'https://www.myinstants.com/media/sounds/cards-flip.mp3', // sample - replace if needed
  chip: 'https://www.myinstants.com/media/sounds/poker-chips.mp3',
  win: 'https://www.myinstants.com/media/sounds/win-sound.mp3',
  lose: 'https://www.myinstants.com/media/sounds/fail-trombone.mp3'
};

/* ========== UTIL & AUDIO ========== */
const $ = id => document.getElementById(id);
function el(tag, cls){ const d = document.createElement(tag); if(cls) d.className = cls; return d; }

let audioCtx = null;
let muted = false;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playSoundUrl(url, vol=0.08){
  if(muted || !url) return;
  // try to play via HTMLAudioElement (simpler cross-origin)
  try{
    const a = new Audio(url);
    a.volume = vol;
    a.play().catch(()=>{/* autoplay might be blocked until user interacts */});
  }catch(e){}
}

/* ========== GAME LOGIC ========== */
class Deck {
  constructor(){ this.reset(); }
  reset(){
    const suits = ['♠','♥','♦','♣'];
    const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    this.cards = [];
    for(const s of suits) for(const r of ranks) this.cards.push({rank:r,suit:s});
    this.shuffle();
  }
  shuffle(){
    for(let i=this.cards.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [this.cards[i], this.cards[j]]=[this.cards[j], this.cards[i]]; }
  }
  draw(){ if(this.cards.length===0) this.reset(); return this.cards.pop(); }
}

class Hand {
  constructor(bet=0){
    this.cards=[]; this.bet=bet; this.stand=false; this.busted=false; this.doubled=false; this.insured=false; this.value=0; this.blackjack=false;
  }
  addCard(c){ this.cards.push(c); this.recalc(); }
  recalc(){
    let sum=0, aces=0;
    for(const c of this.cards){
      if(c.rank==='A'){ aces++; sum+=1; }
      else if(['J','Q','K'].includes(c.rank)) sum+=10;
      else sum+=parseInt(c.rank,10);
    }
    for(let i=0;i<aces;i++) if(sum+10 <= 21) sum+=10;
    this.value = sum;
    this.busted = sum > 21;
    this.blackjack = (this.cards.length===2 && sum===21);
  }
}

class Player {
  constructor(name, type='human', bank=1000){
    this.name=name; this.type=type; this.bank=bank; this.hands=[]; this.activeHandIndex=0;
  }
  resetRound(){ this.hands=[]; this.activeHandIndex=0; }
  newHand(bet){ const h=new Hand(bet); this.hands.push(h); return h; }
  currentHand(){ return this.hands[this.activeHandIndex]; }
  advanceHand(){ if(this.activeHandIndex < this.hands.length-1){ this.activeHandIndex++; return true; } return false; }
}

/* global state */
let deck = new Deck();
let players = [];
let dealer = new Player('Dealer','dealer', Infinity);
dealer.newHand(0);
let currentPlayerIdx = 0;
let inRound = false;
let selectedChip = 25;

/* DOM refs */
const logEl = $('log');
const playersConfigEl = $('playersConfig');
const dealerHandEl = $('dealerHand');
const dealerValEl = $('dealerVal');
const tableCircle = $('tableCircle');
const felt = $('felt');
const balancesEl = $('balances');
const statusEl = $('status');

/* helpers */
function lg(msg){
  const d = document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  logEl.prepend(d);
}
function updateStatus(s){ statusEl.textContent = s; }

/* ========== SETUP UI ========== */
function makePlayersConfig(){
  playersConfigEl.innerHTML = '';
  const n = Math.max(1, Math.min(7, parseInt($('numPlayers').value)||1));
  const botRate = parseInt($('botRate').value)||0;
  const startBank = parseInt($('startBank').value)||1000;
  for(let i=0;i<n;i++){
    const row = el('div','player-row');
    const name = el('input'); name.type='text'; name.value=`Player ${i+1}`;
    const typeSel = el('select');
    const h = el('option'); h.value='human'; h.text='Mensch';
    const b = el('option'); b.value='bot'; b.text='Bot';
    typeSel.appendChild(h); typeSel.appendChild(b);
    if(i < botRate) typeSel.value='bot';
    const bank = el('input'); bank.type='number'; bank.value=startBank; bank.min=0; bank.style.width='90px';
    row.appendChild(name); row.appendChild(typeSel); row.appendChild(bank);
    playersConfigEl.appendChild(row);
  }
}
$('setupBtn').addEventListener('click', makePlayersConfig);
makePlayersConfig();

/* read card back input */
$('cardBackInput').addEventListener('change', (e)=>{
  CARD_BACK_URL = e.target.value.trim();
  // set CSS variable for card back
  if(CARD_BACK_URL){
    document.documentElement.style.setProperty('--card-back-url', `url("${CARD_BACK_URL}")`);
    // used by .card.hidden
    document.querySelectorAll('.card.hidden').forEach(c=> c.style.backgroundImage = `url("${CARD_BACK_URL}")`);
  }
});

/* chip picker */
document.querySelectorAll('.chip').forEach(ch=>{
  ch.addEventListener('click', ()=>{
    document.querySelectorAll('.chip').forEach(x=>x.style.boxShadow='0 8px 22px rgba(0,0,0,0.45)');
    ch.style.boxShadow='0 16px 38px rgba(0,0,0,0.6) inset';
    selectedChip = parseInt(ch.dataset.value);
  });
});

/* mute/sound test */
$('muteBtn').addEventListener('click', ()=>{
  muted = !muted; $('muteBtn').textContent = muted ? 'Stumm' : 'Ton an';
});
$('sampleSounds').addEventListener('click', ()=> {
  playSoundUrl(SOUND.card,0.12); setTimeout(()=>playSoundUrl(SOUND.chip,0.12),120);
});

/* ========== BUILD PLAYERS & CIRCLE LAYOUT ========== */
function buildPlayersFromConfig(){
  players = [];
  const rows = Array.from(playersConfigEl.children);
  for(const r of rows){
    const name = r.querySelector('input[type=text]').value || 'Player';
    const type = r.querySelector('select').value;
    const bank = parseInt(r.querySelector('input[type=number]').value)||1000;
    players.push(new Player(name, type, bank));
  }
  // reset dealer hand
  dealer = new Player('Dealer','dealer', Infinity);
  dealer.newHand(0);
  renderCircleSlots();
  updateBalances();
}

function renderCircleSlots(){
  // remove previous slots
  const existing = [...tableCircle.querySelectorAll('.player-slot')];
  existing.forEach(x=>x.remove());
  const n = players.length;
  const radius = 38; // percent from center
  for(let i=0;i<n;i++){
    const angle = (360 / n) * i - 90; // start top
    const rad = angle * Math.PI/180;
    // compute position relative to center of felt
    const slot = el('div','player-slot');
    // set transform: translate to center then shift by radius along angle
    // We'll use absolute positioning with left/top in percent.
    const cx = 50 + Math.cos(rad) * radius;
    const cy = 50 + Math.sin(rad) * radius;
    slot.style.left = cx + '%';
    slot.style.top = cy + '%';
    slot.style.transform = 'translate(-50%,-50%)';
    // content
    const name = el('div','player-name'); name.textContent = players[i].name;
    const bal = el('div','player-balance'); bal.textContent = players[i].bank + ' €';
    const handWrap = el('div','player-hand'); handWrap.id = `hand-${i}`;
    slot.appendChild(name); slot.appendChild(bal); slot.appendChild(handWrap);
    // store index
    slot.dataset.index = i;
    tableCircle.appendChild(slot);
  }
  renderDealer(); // ensure dealer center exists
}

/* render dealer small hand */
function renderDealer(){
  dealerHandEl.innerHTML = '';
  const hand = dealer.hands[0];
  for(let i=0;i<hand.cards.length;i++){
    const c = hand.cards[i];
    const cardEl = makeCardElement(c, (inRound && i===1 && !dealer.revealed));
    dealerHandEl.appendChild(cardEl);
  }
  dealerValEl.textContent = (inRound && dealer.revealed) ? `→ ${hand.value}` : (inRound ? '→ ?' : '');
}

/* create card DOM element */
function makeCardElement(card, hidden=false){
  const c = el('div','card' + (hidden ? ' hidden' : ''));
  if(hidden){
    // background image set via CSS var if provided, else simple pattern
    if(CARD_BACK_URL) c.style.backgroundImage = `url("${CARD_BACK_URL}")`;
    else c.style.background = 'linear-gradient(135deg,#123,#052)';
    return c;
  }
  if(card && (card.suit==='♥' || card.suit==='♦')) c.classList.add('red');
  const top = el('div'); top.className='rank'; top.textContent = card.rank;
  const mid = el('div'); mid.className='suit'; mid.textContent = card.suit;
  const bot = el('div'); bot.className='rank'; bot.textContent = card.rank;
  c.appendChild(top); c.appendChild(mid); c.appendChild(bot);
  return c;
}

/* ========== GAME FLOW ========== */
$('startBtn').addEventListener('click', ()=>{
  buildPlayersFromConfig();
  hideSetup(true);
  $('dealBtn').disabled = false;
  updateStatus('Setup geladen — bereit zum Geben');
});

$('dealBtn').addEventListener('click', dealRound);
$('nextBtn').addEventListener('click', ()=> { advanceToNext(); });

function hideSetup(hide){
  const sidebar = $('sidebar');
  if(hide){
    sidebar.classList.add('hide-sidebar');
    // make board fullscreen
    document.querySelector('.board').classList.add('fullscreen');
  } else {
    sidebar.classList.remove('hide-sidebar');
    document.querySelector('.board').classList.remove('fullscreen');
  }
}

/* Deal round */
function dealRound(){
  if(players.length===0){ lg('Keine Spieler'); return; }
  // reset round state
  deck = new Deck();
  for(const p of players){ p.resetRound(); }
  dealer = new Player('Dealer','dealer', Infinity);
  dealer.newHand(0);
  inRound = true;
  // take bets (for now: each player bets selectedChip or available bank)
  for(const p of players){
    const bet = Math.max(1, Math.min(p.bank, selectedChip));
    p.bank -= bet;
    p.newHand(bet);
  }
  // initial deal: 2 cards each, dealer 2 (one hidden)
  for(let r=0;r<2;r++){
    for(const p of players){
      const c = deck.draw(); p.hands[0].addCard(c);
    }
    dealer.hands[0].addCard(deck.draw());
  }
  dealer.revealed = false;
  currentPlayerIdx = 0;
  renderAllHands();
  $('dealBtn').disabled = true;
  $('nextBtn').disabled = false;
  lg('Karten verteilt');
  updateBalances();
  processCurrentPlayer();
}

/* render all hands to DOM */
function renderAllHands(){
  // players
  for(let i=0;i<players.length;i++){
    const wrap = $(`hand-${i}`);
    wrap.innerHTML = '';
    const p = players[i];
    for(const h of p.hands){
      for(const card of h.cards){
        const cardEl = makeCardElement(card,false);
        wrap.appendChild(cardEl);
      }
      // show bet below
      const info = el('div'); info.style.fontSize='0.85rem'; info.style.color='#e8ffef';
      info.textContent = `${h.value || 0} (${h.bet}€)${h.busted ? ' BUST' : h.blackjack ? ' BJ' : ''}`;
      wrap.appendChild(info);
    }
    // set current class
    const slot = tableCircle.querySelector(`.player-slot[data-index="${i}"]`);
    if(slot) slot.classList.toggle('current', i===currentPlayerIdx);
    // update balance text
    if(slot) slot.querySelector('.player-balance').textContent = players[i].bank + ' €';
  }
  // dealer
  renderDealer();
  updateBalances();
}

/* update balances summary */
function updateBalances(){
  balancesEl.textContent = players.map(p => `${p.name}: ${p.bank}€`).join(' · ');
}

/* process current player (bot or human) */
function processCurrentPlayer(){
  if(!inRound) return;
  // check if all players done
  const anyActive = players.some(p => p.hands.some(h => !h.stand && !h.busted && !h.blackjack));
  if(!anyActive){
    // dealer's turn
    dealerTurn();
    return;
  }
  // ensure currentPlayerIdx points to a player with active hand
  let found=false;
  for(let i=0;i<players.length;i++){
    const idx = (currentPlayerIdx + i) % players.length;
    const p = players[idx];
    if(p.hands.some(h=>!h.stand && !h.busted && !h.blackjack)){ currentPlayerIdx = idx; found=true; break; }
  }
  if(!found){ dealerTurn(); return; }
  renderAllHands();
  const p = players[currentPlayerIdx];
  lg(`${p.name} ist dran`);
  updateStatus(`${p.name} ist dran`);
  if(p.type === 'bot'){
    setTimeout(()=> botPlay(p), 700);
  } else {
    // human: enable buttons
    enableActionButtons(true);
  }
}

/* enable/disable action buttons */
function enableActionButtons(enable){
  $('hitBtn').disabled = !enable;
  $('standBtn').disabled = !enable;
  $('doubleBtn').disabled = !enable;
  $('splitBtn').disabled = !enable;
  $('insureBtn').disabled = !enable;
}

/* player action UI */
$('hitBtn').addEventListener('click', ()=> playerAction('hit'));
$('standBtn').addEventListener('click', ()=> playerAction('stand'));
$('doubleBtn').addEventListener('click', ()=> playerAction('double'));
$('splitBtn').addEventListener('click', ()=> playerAction('split'));
$('insureBtn').addEventListener('click', ()=> playerAction('insure'));

/* action execution (works for bot and human) */
function playerAction(type){
  const p = players[currentPlayerIdx];
  playerActionFor(p, type);
}
function playerActionFor(p, type){
  enableActionButtons(false);
  const h = p.currentHand();
  if(!h){ advanceToNext(); return; }
  if(type==='hit'){
    const c = deck.draw(); h.addCard(c);
    playSoundUrl(SOUND.card, 0.12);
    lg(`${p.name} zieht ${c.rank}${c.suit} → ${h.value}`);
    if(h.busted){ lg(`${p.name} busted (${h.value})`); playSoundUrl(SOUND.lose,0.12); }
    setTimeout(()=> { if(!h.busted && !h.stand) enableActionButtons(true); if(h.busted || h.stand || h.blackjack) advanceToNext(); renderAllHands(); }, 300);
  } else if(type==='stand'){
    h.stand = true; lg(`${p.name} steht mit ${h.value}`); setTimeout(()=> advanceToNext(), 200);
  } else if(type==='double'){
    if(h.cards.length !== 2){ lg('Double nur auf den ersten 2 Karten erlaubt'); return; }
    if(p.bank < h.bet){ lg('Nicht genug Guthaben zum Verdoppeln'); return; }
    p.bank -= h.bet; h.bet *= 2; h.doubled = true;
    const c = deck.draw(); h.addCard(c); h.stand = true;
    playSoundUrl(SOUND.card,0.12); playSoundUrl(SOUND.chip,0.08);
    lg(`${p.name} verdoppelt und zieht ${c.rank}${c.suit} → ${h.value}`);
    setTimeout(()=> advanceToNext(), 400);
  } else if(type==='split'){
    if(h.cards.length !== 2 || h.cards[0].rank !== h.cards[1].rank){ lg('Split nur bei Paaren möglich'); return; }
    if(p.bank < h.bet){ lg('Nicht genug Guthaben zum Split'); return; }
    p.bank -= h.bet;
    const second = h.cards.pop(); h.recalc();
    const newH = p.newHand(h.bet);
    newH.addCard(second);
    // draw one card each
    h.addCard(deck.draw());
    newH.addCard(deck.draw());
    lg(`${p.name} splittet die Hand`);
    renderAllHands();
  } else if(type==='insure'){
    // only if dealer upcard is Ace
    const dealerUp = dealer.hands[0].cards[0];
    if(!dealerUp || dealerUp.rank !== 'A'){ lg('Insurance nur bei Dealer Ass verfügbar'); return; }
    if(p.bank < h.bet/2){ lg('Nicht genug Guthaben für Insurance'); return; }
    p.bank -= h.bet/2; h.insured = true;
    lg(`${p.name} kauft Insurance (${h.bet/2}€)`);
  }
  renderAllHands();
  updateBalances();
}

/* advance to next player's active hand */
function advanceToNext(){
  const p = players[currentPlayerIdx];
  if(p.advanceHand()){
    renderAllHands();
    processCurrentPlayer();
    return;
  }
  // find next player with unsettled hand
  for(let offset=1; offset<=players.length; offset++){
    const ni = (currentPlayerIdx + offset) % players.length;
    const np = players[ni];
    if(np.hands.some(h=>!h.stand && !h.busted && !h.blackjack)){
      currentPlayerIdx = ni;
      renderAllHands();
      processCurrentPlayer();
      return;
    }
  }
  // none left -> dealer
  dealerTurn();
}

/* Bot logic (basic improved heuristic) */
function botPlay(p){
  const h = p.currentHand();
  if(!h){ advanceToNext(); return; }
  // if can split beneficial pairs
  if(h.cards.length===2 && h.cards[0].rank === h.cards[1].rank){
    if(h.cards[0].rank==='A' || h.cards[0].rank==='8'){
      lg(`${p.name} (Bot) entscheidet: Split`); setTimeout(()=> playerActionFor(p,'split'), 400); return;
    }
  }
  // double condition
  if(h.cards.length===2 && (h.value===9 || h.value===10 || h.value===11) && p.bank >= h.bet){
    if(Math.random() < 0.6){ lg(`${p.name} (Bot) entscheidet: Double`); setTimeout(()=> playerActionFor(p,'double'), 500); return; }
  }
  // standard hit/stand logic with dealer upcard check
  const dealerUp = dealer.hands[0].cards[0];
  const dealerUpVal = getCardValForStrat(dealerUp);
  if(h.value <= 11){ setTimeout(()=> playerActionFor(p,'hit'), 450); return; }
  if(h.value >= 17){ setTimeout(()=> playerActionFor(p,'stand'), 450); return; }
  if(h.value >= 12 && h.value <= 16){
    if(dealerUpVal >=2 && dealerUpVal <=6){ setTimeout(()=> playerActionFor(p,'stand'), 450); return; }
    else setTimeout(()=> playerActionFor(p,'hit'), 450);
    return;
  }
  setTimeout(()=> playerActionFor(p,'stand'), 450);
}
function getCardValForStrat(c){
  if(!c) return 0;
  if(c.rank === 'A') return 11;
  if(['J','Q','K'].includes(c.rank)) return 10;
  return parseInt(c.rank,10);
}

/* Dealer turn */
function dealerTurn(){
  enableActionButtons(false);
  dealer.revealed = true;
  renderDealer();
  lg('Dealer deckt auf und spielt');
  // check for blackjack
  const dHand = dealer.hands[0];
  if(dHand.blackjack){
    lg('Dealer hat Blackjack!');
    finalizeRound();
    return;
  }
  // dealer draws until >=17
  const step = ()=>{
    dHand.recalc();
    if(dHand.value < 17){
      const c = deck.draw(); dHand.addCard(c);
      playSoundUrl(SOUND.card,0.12);
      lg(`Dealer zieht ${c.rank}${c.suit} → ${dHand.value}`);
      renderDealer();
      setTimeout(step, 700);
    } else {
      lg(`Dealer steht mit ${dHand.value}`);
      renderDealer();
      setTimeout(finalizeRound, 600);
    }
  };
  setTimeout(step, 700);
}

/* finalize round: compare and pay */
function finalizeRound(){
  lg('--- Runde beendet: Auswertung ---');
  const dHand = dealer.hands[0];
  const dVal = dHand.value;
  const dBlack = dHand.blackjack;
  const dBusted = dHand.busted;
  for(const p of players){
    for(const h of p.hands){
      if(h.insured){
        if(dBlack){ const payout = h.bet; p.bank += payout; lg(`${p.name} erhält Insurance payout ${payout}€`); }
        else lg(`${p.name} verliert Insurance.`);
      }
      if(h.busted){ lg(`${p.name} verliert Hand (${h.bet}€) — busted`); continue; }
      if(h.blackjack && !dBlack){
        const payout = Math.round(h.bet * 2.5); p.bank += payout; lg(`${p.name} Blackjack! Auszahlung ${payout}€`); continue;
      }
      if(h.blackjack && dBlack){
        p.bank += h.bet; lg(`${p.name} Push (beide Blackjack)`); continue;
      }
      if(dBusted){ const payout = h.bet*2; p.bank += payout; lg(`${p.name} gewinnt (Dealer busted). Auszahlung ${payout}€`); continue; }
      if(h.value > dVal){ const payout = h.bet*2; p.bank += payout; lg(`${p.name} gewinnt (${h.value} vs ${dVal}). Auszahlung ${payout}€`); }
      else if(h.value === dVal){ p.bank += h.bet; lg(`${p.name} Push (${h.value}) — Einsatz zurück`); }
      else { lg(`${p.name} verliert (${h.value} vs ${dVal}) — Einsatz verloren`); }
    }
  }
  inRound = false;
  $('dealBtn').disabled = false;
  $('nextBtn').disabled = true;
  renderAllHands();
  updateBalances();
  hideSetup(false);
  updateStatus('Runde beendet');
}

/* ========== Utilities & initial UI state ========== */
function renderAllHands(){ renderAllHands; /* noop to avoid linting */ }
function renderAllHands(){ /* alias fix */ 
  renderAllHands = function(){};
}
renderAllHands = function(){
  renderAllHands = arguments.callee.caller || function(){};
}; // dummy to avoid repeated definitions - we'll use the real function defined earlier
// Actually reassign to the proper function implemented above:
renderAllHands = function(){ // replace with earlier implementation by calling global function defined above
  // re-run the implementation block: (we already implemented actual function earlier in code; use that one)
  // For safety, we simply call the explicit rendering functions:
  for(let i=0;i<players.length;i++){
    const wrap = $(`hand-${i}`);
    if(!wrap) continue;
    wrap.innerHTML = '';
    const p = players[i];
    for(const h of p.hands){
      for(const card of h.cards){
        const cardEl = makeCardElement(card,false);
        wrap.appendChild(cardEl);
      }
      const info = el('div'); info.style.fontSize='0.85rem'; info.style.color='#e8ffef';
      info.textContent = `${h.value || 0} (${h.bet}€)${h.busted ? ' BUST' : h.blackjack ? ' BJ' : ''}`;
      wrap.appendChild(info);
    }
    const slot = tableCircle.querySelector(`.player-slot[data-index="${i}"]`);
    if(slot) slot.classList.toggle('current', i===currentPlayerIdx);
    if(slot) slot.querySelector('.player-balance').textContent = players[i].bank + ' €';
  }
  renderDealer();
  updateBalances();
};

/* initial UI state */
$('dealBtn').disabled = true;
$('nextBtn').disabled = true;
updateStatus('Bereit — Setup konfigurieren');
lg('Interface geladen. Erzeuge Setup und klicke Spiel starten.');

/* create slots when page loads for initial config */
window.addEventListener('load', ()=>{
  makePlayersConfig();
});

</script>
</body>
</html>
