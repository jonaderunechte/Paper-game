<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blackjack â€” Round Table (GitHub Pages)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b3b2e;
    --felt:#0c6b4a; /* grÃ¼ner Filz */
    --panel: rgba(0,0,0,0.22);
    --accent:#ffd166;
    --muted:#cfeee4;
    --white:#ffffff;
    --shadow: 0 10px 40px rgba(0,0,0,0.6);
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; margin:0; font-family:Inter,system-ui,Arial; background:linear-gradient(#062b22,#032017); color:var(--muted); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  /* App container */
  .app{
    width:100%; max-width:1400px; margin:18px auto; border-radius:14px; overflow:hidden; box-shadow:var(--shadow);
    display:grid; grid-template-columns: 320px 1fr; gap:14px; padding:14px;
  }
  @media (max-width:1000px){ .app{ grid-template-columns: 1fr; padding:10px; } }

  /* SIDEBAR / SETUP */
  aside.sidebar{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px; border-radius:10px; min-height:520px; display:flex; flex-direction:column; gap:10px;
    transition: all .4s ease;
  }
  aside.sidebar.hidden{ opacity:0; transform:scale(.98); pointer-events:none; width:0; padding:0; margin:0; }
  .brand{ display:flex; gap:10px; align-items:center; }
  .logo{ width:56px; height:56px; border-radius:10px; background:linear-gradient(90deg,var(--accent),#ff9f1c); display:flex; align-items:center; justify-content:center; font-weight:800; color:#042; }
  h1{ margin:0; font-size:1.05rem; color:var(--accent); }
  .muted{ color:#bfeee1; font-size:.90rem; }

  .control-row{ display:flex; gap:8px; align-items:center; }
  label{ font-size:0.9rem; color:var(--muted); }
  select,input[type=number],input[type=text]{ padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); }

  .players-list{ display:flex; flex-direction:column; gap:8px; max-height:300px; overflow:auto; padding-right:6px; }
  .player-config{ display:flex; gap:8px; align-items:center; background:rgba(0,0,0,0.12); padding:8px; border-radius:8px; }

  .btn{ padding:10px 12px; border-radius:9px; border:none; cursor:pointer; font-weight:700; }
  .btn.primary{ background:linear-gradient(90deg,var(--accent), #ff9f1c); color:#042; }
  .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); }

  /* BOARD (rechts) - Tisch */
  .board-wrap{ display:flex; flex-direction:column; gap:10px; }
  .board{
    background: radial-gradient(circle at 50% 18%, rgba(255,255,255,0.02), transparent 20%), var(--felt);
    border-radius:12px; padding:18px; min-height:640px; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden;
    transition: all .4s ease;
  }
  /* Make board expand when sidebar hidden */
  .board.expanded{ min-height:760px; padding:28px; }

  /* table circle */
  .table-circle{ width:100%; max-width:980px; aspect-ratio:1.6/1; position:relative; display:block; }
  @media (max-width:900px){ .table-circle{ max-width:100%; aspect-ratio:1/1; } }

  /* dealer center */
  .dealer{
    position:absolute; left:50%; top:48%; transform:translate(-50%,-50%); display:flex; flex-direction:column; align-items:center; gap:8px;
  }
  .dealer .small-hand{ display:flex; gap:8px; align-items:center; }
  .dealer .dealer-label{ color:var(--accent); font-weight:800; margin-top:6px; }

  /* player seats arranged circularly using CSS variables */
  .seat{
    position:absolute; width:260px; height:160px; display:flex; flex-direction:column; align-items:center; gap:8px;
    transform-origin:center center;
  }
  .seat .player-title{ font-weight:700; color:var(--accent); }
  .seat .player-bank{ font-size:.9rem; color:#bfeee1; margin-bottom:4px; }
  .seat .hand-large{ display:flex; gap:8px; align-items:center; justify-content:center; }
  .seat .hand-small{ display:flex; gap:6px; align-items:center; justify-content:center; }

  /* position seats via inline style (--angle) */
  .seat[data-angle]{
    /* place at angle on an ellipse */
    --rX: 42%; --rY: 36%;
    left: calc(50% + var(--rX) * cos(var(--angle))); /* not directly usable - we'll compute transform in JS */
  }

  /* We'll set transform via JS per seat */

  /* Card visuals */
  .card{
    width:84px; height:120px; border-radius:10px; background:var(--white); color:#000; box-shadow:0 10px 20px rgba(0,0,0,0.45);
    display:flex; flex-direction:column; justify-content:space-between; padding:8px; user-select:none; transform-origin:center center;
    transition: transform 300ms cubic-bezier(.2,.9,.3,1), box-shadow 200ms;
  }
  .card.small{ width:64px; height:92px; }
  .card .rank{ font-weight:800; font-size:1.05rem; }
  .card .suit{ font-size:1.4rem; opacity:0.95; text-align:center; }
  .card.red .rank, .card.red .suit{ color:#b30d0d; }
  .card.hidden{
    width:84px; height:120px; border-radius:10px; background-image: url('cards-back.png'); background-size:cover; background-position:center; box-shadow:none;
  }
  .card.flip-enter{ transform: rotateY(90deg); }
  .card.flip-show{ transform: rotateY(0deg); }

  /* highlight current player by making cards larger */
  .seat.current .card{ transform: translateY(-6px) scale(1.08); box-shadow:0 20px 40px rgba(0,0,0,0.6); }

  /* action buttons bubble near bottom */
  .actions-global{ position:fixed; left:50%; transform:translateX(-50%); bottom:18px; display:flex; gap:8px; z-index:40; }
  .chip{ background:linear-gradient(180deg,#fff,#ddd); padding:8px 12px; border-radius:999px; font-weight:800; color:#042; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.25); }
  .chip.active{ box-shadow:0 12px 28px rgba(3,120,100,0.18); transform:translateY(-6px); }

  /* log panel small top-right */
  .log{
    position:absolute; right:12px; top:12px; width:260px; max-height:220px; overflow:auto; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px; font-size:0.9rem;
  }

  /* bottom-left small HUD */
  .hud{
    position:absolute; left:12px; bottom:12px; background:rgba(0,0,0,0.14); padding:8px 10px; border-radius:8px; display:flex; gap:10px; align-items:center;
  }

  /* responsive tweaks */
  @media (max-width:700px){
    .seat{ width:160px; height:120px; }
    .card{ width:64px; height:92px; }
    .card.small{ width:54px; height:76px; }
    .actions-global{ bottom:8px; gap:6px; }
    aside.sidebar{ display:none; } /* mobile: hide sidebar by default */
  }

</style>
</head>
<body>
<div style="padding:12px; text-align:center; color:var(--muted); font-weight:700;">Blackjack â€” Round Table (Hotseat). Lade `cards-back.png` in dasselbe Repo fÃ¼r die KartenrÃ¼ckseite.</div>

<div class="app" id="app">

  <!-- SIDEBAR -->
  <aside class="sidebar" id="sidebar">
    <div class="brand">
      <div class="logo">BJ</div>
      <div>
        <h1>Blackjack Round Table</h1>
        <div class="muted">Hotseat â€¢ Bots â€¢ Responsive</div>
      </div>
    </div>

    <div>
      <label>Spieleranzahl (1â€“6)</label>
      <div class="control-row">
        <input id="numPlayers" type="number" min="1" max="6" value="3" />
        <select id="botCount"><option value="0">0 Bots</option><option value="1">1 Bot</option><option value="2">2 Bots</option></select>
        <div style="flex:1"></div>
        <button class="btn primary" id="startBtn">Spiel starten</button>
      </div>
    </div>

    <div>
      <label>Startguthaben (â‚¬)</label>
      <input id="startBank" type="number" min="10" value="1000" />
    </div>

    <div>
      <label>Einstellungen</label>
      <div style="display:flex; gap:8px; margin-top:6px;">
        <button class="btn ghost" id="resetBtn">Neu Laden</button>
        <button class="btn ghost" id="muteBtn">ðŸ”Š</button>
      </div>
    </div>

    <div style="flex:1;">
      <label>Spieler (klicke zum bearbeiten)</label>
      <div class="players-list" id="playersConfig"></div>
    </div>

    <div style="font-size:0.85rem; color:#bfeee1;">
      Regeln: Single-deck (Auto-Neumischen), Double (nur 2 Karten), Split (einfach), Insurance verfÃ¼gbar bei Dealer Ass. Hotseat: Spieler nacheinander auf einem GerÃ¤t.
    </div>
  </aside>

  <!-- BOARD -->
  <main class="board-wrap">
    <div class="board" id="board">
      <div class="table-circle" id="tableCircle">
        <!-- Dealer center -->
        <div class="dealer" id="dealer">
          <div class="small-hand" id="dealerHand"></div>
          <div class="dealer-label">Dealer</div>
        </div>
        <!-- Seats will be injected here -->
      </div>

      <div class="log" id="log"></div>
      <div class="hud" id="hud">
        <div id="betInfo">Einsatz: <strong id="currentBet">25â‚¬</strong></div>
        <div id="bankInfo">Konten:</div>
      </div>
    </div>

    <!-- Actions bottom -->
    <div style="display:flex; justify-content:space-between; align-items:center; padding:8px;">
      <div>
        <div style="display:flex; gap:8px; align-items:center;">
          <div class="chip" data-value="10">10</div>
          <div class="chip active" data-value="25">25</div>
          <div class="chip" data-value="50">50</div>
          <div class="chip" data-value="100">100</div>
        </div>
      </div>
      <div class="actions-global" id="globalActions">
        <button class="btn btn.primary" id="dealBtn" disabled>Geben</button>
        <button class="btn btn.ghost" id="hitBtn" disabled>Hit</button>
        <button class="btn btn.ghost" id="standBtn" disabled>Stand</button>
        <button class="btn btn.ghost" id="doubleBtn" disabled>Double</button>
        <button class="btn btn.ghost" id="splitBtn" disabled>Split</button>
        <button class="btn btn.ghost" id="insureBtn" disabled>Insurance</button>
      </div>
    </div>
  </main>
</div>

<script>
/* Blackjack Round Table
   - Hotseat multiplayer
   - Players arranged in circle
   - Dealer in center
   - CSS-based cards, cards-back.png for back (upload to repo)
   - Animated actions + simple sounds (external)
*/

const $ = id => document.getElementById(id);
let audioCtx = null;
let muted = false;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function playTone(freq=700, dur=0.06, vol=0.04){ if(muted) return; ensureAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>o.stop(), dur*1000); }

/* small sound helper for MyInstants style URLs (optional) */
function playUrl(url){
  if(muted) return;
  try{
    const a = new Audio(url);
    a.volume = 0.25;
    a.play().catch(()=>{});
  }catch(e){}
}

/* Configure sound urls (replace if you have better ones) */
const SOUND_CARD = "https://www.myinstants.com/media/sounds/playing-card.mp3";
const SOUND_CHIP = "https://www.myinstants.com/media/sounds/coins-pile.mp3";
const SOUND_WIN = "https://www.myinstants.com/media/sounds/success-fanfare-trumpets.mp3";

/* Deck & game logic */
class Deck {
  constructor(){ this.reset(); }
  reset(){
    const suits=['â™ ','â™¥','â™¦','â™£'];
    const ranks=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    this.cards=[];
    for(const s of suits) for(const r of ranks) this.cards.push({rank:r,suit:s});
    this.shuffle();
  }
  shuffle(){
    for(let i=this.cards.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [this.cards[i],this.cards[j]]=[this.cards[j],this.cards[i]];
    }
  }
  draw(){ if(this.cards.length===0) this.reset(); return this.cards.pop(); }
}

/* Hand and Player */
class Hand {
  constructor(){ this.cards=[]; this.bet=0; this.stand=false; this.busted=false; this.doubled=false; this.insured=false; this.blackjack=false; this.value=0; }
  add(card){ this.cards.push(card); this.recalc(); }
  recalc(){
    let sum=0, aces=0;
    for(const c of this.cards){
      if(c.rank==='A'){ aces++; sum+=1; }
      else if(['J','Q','K'].includes(c.rank)) sum+=10;
      else sum+=parseInt(c.rank,10);
    }
    for(let i=0;i<aces;i++) if(sum+10<=21) sum+=10;
    this.value=sum;
    this.busted = sum>21;
    this.blackjack = (this.cards.length===2 && sum===21);
  }
}

class Player {
  constructor(name, type='human', bank=1000){
    this.name = name; this.type = type; this.bank = bank; this.hands = []; this.activeHandIndex = 0;
  }
  resetRound(){ this.hands=[]; this.activeHandIndex=0; }
  createHand(bet){ const h=new Hand(); h.bet=bet; this.hands.push(h); return h; }
  currentHand(){ return this.hands[this.activeHandIndex]; }
  nextHand(){ if(this.activeHandIndex < this.hands.length-1){ this.activeHandIndex++; return true; } return false; }
}

/* Game state */
let deck = new Deck();
let players = [];
let dealer = new Player('Dealer','dealer', Infinity);
dealer.createHand(0);
let currentPlayerIdx = 0;
let inRound = false;

/* UI references */
const playersConfigEl = document.querySelector('#playersConfig');
const logEl = $('log');
const tableCircle = $('tableCircle');
const dealerHandEl = $('dealerHand');
const boardEl = document.querySelector('.board');
const sidebarEl = document.querySelector('.sidebar');
const dealBtn = $('dealBtn');
const hitBtn = $('hitBtn');
const standBtn = $('standBtn');
const doubleBtn = $('doubleBtn');
const splitBtn = $('splitBtn');
const insureBtn = $('insureBtn');
const startBtn = $('startBtn');
const numPlayersInput = $('numPlayers');
const botCountInput = $('botCount');
const startBankInput = $('startBank');
const chipEls = document.querySelectorAll('.chip');
const currentBetEl = $('currentBet');
const bankInfoEl = $('bankInfo');
const muteBtn = $('muteBtn');

/* helper: log */
function log(msg){ const d=document.createElement('div'); d.textContent=`${new Date().toLocaleTimeString()} â€” ${msg}`; logEl.prepend(d); }

/* render players config inside sidebar */
function renderPlayersConfig(){
  playersConfigEl.innerHTML='';
  const n = clamp(parseInt(numPlayersInput.value,10) || 1,1,6);
  const botCount = clamp(parseInt(botCountInput.value,10) || 0,0,n);
  for(let i=0;i<n;i++){
    const div=document.createElement('div'); div.className='player-config';
    const nameIn=document.createElement('input'); nameIn.type='text'; nameIn.value=`Player ${i+1}`;
    const typeSel=document.createElement('select');
    const o1=document.createElement('option'); o1.value='human'; o1.text='Mensch';
    const o2=document.createElement('option'); o2.value='bot'; o2.text='Bot';
    typeSel.appendChild(o1); typeSel.appendChild(o2);
    if(i<botCount) typeSel.value='bot';
    const bankIn=document.createElement('input'); bankIn.type='number'; bankIn.value=startBankInput.value; bankIn.style.width='110px';
    div.appendChild(nameIn); div.appendChild(typeSel); div.appendChild(bankIn);
    playersConfigEl.appendChild(div);
  }
}
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
numPlayersInput.addEventListener('change', renderPlayersConfig);
botCountInput.addEventListener('change', renderPlayersConfig);
startBankInput.addEventListener('change', renderPlayersConfig);
renderPlayersConfig();

/* build players array from UI */
function buildPlayersFromUI(){
  players = [];
  const items = Array.from(playersConfigEl.children);
  for(const it of items){
    const name = it.querySelector('input[type=text]').value || 'Player';
    const type = it.querySelector('select').value;
    const bank = parseInt(it.querySelector('input[type=number]').value,10) || 1000;
    players.push(new Player(name,type,bank));
  }
  dealer = new Player('Dealer','dealer', Infinity);
  dealer.createHand(0);
  currentPlayerIdx = 0;
  updateBankInfo();
  renderTableSeats();
}

/* render seats in circular layout */
function renderTableSeats(){
  // clear previous seats
  // remove existing seat elements
  const prev = Array.from(document.querySelectorAll('.seat'));
  prev.forEach(x=>x.remove());
  const n = players.length;
  const centerX = tableCircle.clientWidth/2;
  const centerY = tableCircle.clientHeight/2;
  const radiusX = Math.min(centerX,centerY) * 0.78;
  const radiusY = radiusX * 0.64;
  for(let i=0;i<n;i++){
    const p = players[i];
    const angle = -90 + (360/n)*i; // start top (-90)
    const rad = angle * Math.PI/180;
    const x = centerX + Math.cos(rad) * radiusX - 130; // offset half seat width (~260/2)
    const y = centerY + Math.sin(rad) * radiusY - 80;  // offset half seat height (~160/2)
    const seat = document.createElement('div'); seat.className='seat'; seat.dataset.index = i;
    seat.style.left = `${x}px`; seat.style.top = `${y}px`;
    seat.style.transform = `rotate(${angle}deg) translateY(0) rotate(${-angle}deg)`; // rotate seat to face center
    // seat contents
    const title = document.createElement('div'); title.className='player-title'; title.textContent = p.name;
    const bank = document.createElement('div'); bank.className='player-bank'; bank.textContent = `${p.bank}â‚¬`;
    const handLarge = document.createElement('div'); handLarge.className='hand-large';
    const handSmall = document.createElement('div'); handSmall.className='hand-small';

    seat.appendChild(title);
    seat.appendChild(bank);
    seat.appendChild(handLarge);
    seat.appendChild(handSmall);

    tableCircle.appendChild(seat);
  }
  renderDealer();
  renderHands();
}

/* render dealer cards area */
function renderDealer(){
  dealerHandEl.innerHTML='';
  const hand = dealer.hands[0];
  for(let i=0;i<hand.cards.length;i++){
    const c = hand.cards[i];
    const isHidden = inRound && !dealer.revealed && i===1;
    const el = createCardElement(c, isHidden, true);
    dealerHandEl.appendChild(el);
  }
}

/* create card element (CSS) */
function createCardElement(card, hidden=false, small=false){
  const el = document.createElement('div'); el.className = 'card' + (small? ' small':'');
  if(hidden){ el.classList.add('hidden'); return el; }
  if(!card){ el.textContent=''; return el; }
  if(card.suit==='â™¥' || card.suit==='â™¦') el.classList.add('red');
  const top = document.createElement('div'); top.className='rank'; top.textContent = card.rank;
  const mid = document.createElement('div'); mid.className='suit'; mid.textContent = card.suit;
  const bot = document.createElement('div'); bot.className='rank'; bot.textContent = card.rank;
  el.appendChild(top); el.appendChild(mid); el.appendChild(bot);
  return el;
}

/* render players' hands into seats */
function renderHands(){
  const seats = Array.from(document.querySelectorAll('.seat'));
  seats.forEach(s=>{ s.querySelector('.hand-large').innerHTML=''; s.querySelector('.hand-small').innerHTML=''; s.querySelector('.player-bank').textContent = players[parseInt(s.dataset.index)].bank + 'â‚¬'; s.classList.remove('current'); });

  for(let i=0;i<players.length;i++){
    const p = players[i];
    const seat = seats.find(s=>parseInt(s.dataset.index)===i);
    if(!seat) continue;
    const large = seat.querySelector('.hand-large');
    const small = seat.querySelector('.hand-small');
    // show first hand cards large if current player
    for(let hi=0; hi<p.hands.length; hi++){
      const h = p.hands[hi];
      const container = (i===currentPlayerIdx ? large : small);
      for(let ci=0; ci<h.cards.length; ci++){
        const c = h.cards[ci];
        const el = createCardElement(c, false, i===currentPlayerIdx ? false : true);
        container.appendChild(el);
      }
      // if split, separate with small spacer
      if(hi < p.hands.length-1){
        const sep = document.createElement('div'); sep.style.width='10px'; container.appendChild(sep);
      }
    }
    // mark current seat
    if(i===currentPlayerIdx && inRound){
      seat.classList.add('current');
    }
  }
  renderDealer();
}

/* betting UI */
let selectedChip = 25;
chipEls.forEach(ch => {
  ch.addEventListener('click', ()=>{
    chipEls.forEach(x=>x.classList.remove('active'));
    ch.classList.add('active');
    selectedChip = parseInt(ch.dataset.value,10);
    currentBetEl.textContent = selectedChip + 'â‚¬';
    playTone(900,0.06,0.04);
  });
});

/* Start game -> build players and show table */
startBtn.addEventListener('click', ()=> {
  buildPlayersFromUI();
  hideSetup(true);
  $('dealBtn').disabled=false;
  log('Setup fertig. Klicke "Geben", um die Runde zu starten.');
});

/* hide/show setup (sidebar) and expand table */
function hideSetup(hide){
  if(hide){
    sidebarEl.classList.add('hidden');
    boardEl.classList.add('expanded');
  } else {
    sidebarEl.classList.remove('hidden');
    boardEl.classList.remove('expanded');
  }
}

/* Deal button */
dealBtn.addEventListener('click', ()=> {
  if(inRound) return;
  // take bets
  for(const p of players){
    p.resetRound();
    let bet;
    if(p.type==='human') bet = Math.min(selectedChip, Math.max(10, Math.floor(p.bank))); // take selected chip or up to bank
    else bet = Math.min(p.bank, Math.max(10, Math.round(selectedChip * (0.5 + Math.random()*1.6))));
    p.bank -= bet;
    p.createHand(bet);
  }
  // dealer new hand
  dealer.resetRound();
  dealer.createHand(0);
  // give cards
  if(deck.cards.length < 20) deck.reset();
  for(let r=0;r<2;r++){
    for(const p of players){
      p.hands[0].add(deck.draw());
    }
    dealer.hands[0].add(deck.draw());
  }
  inRound = true;
  dealer.revealed = false;
  currentPlayerIdx = 0;
  renderHands();
  renderDealer();
  updateBankInfo();
  $('dealBtn').disabled=true;
  enableActionButtonsForCurrent();
  // auto-play bots if current is bot
  setTimeout(()=> processCurrentIfBot(), 400);
  log('Karten verteilt. Runde lÃ¤uft.');
  playUrl(SOUND_CARD);
});

/* enable action buttons depending on state */
function enableActionButtonsForCurrent(){
  if(!inRound) { disableAllActions(); return; }
  const p = players[currentPlayerIdx];
  const h = p.currentHand();
  // disable all
  disableAllActions();
  // only enable for human
  if(p.type==='human'){
    hitBtn.disabled = !(h && !h.stand && !h.busted);
    standBtn.disabled = hitBtn.disabled;
    doubleBtn.disabled = !(h && h.cards.length===2 && p.bank >= h.bet);
    splitBtn.disabled = !(h && h.cards.length===2 && h.cards[0].rank === h.cards[1].rank && p.bank >= h.bet);
    // insurance only if dealer upcard Ace
    const dUp = dealer.hands[0].cards[0];
    insureBtn.disabled = !(dUp && dUp.rank === 'A' && !h.insured && p.bank >= Math.ceil(h.bet/2));
  }
  // if bot, keep actions disabled (bot will auto act)
}
function disableAllActions(){
  hitBtn.disabled = true; standBtn.disabled = true; doubleBtn.disabled = true; splitBtn.disabled = true; insureBtn.disabled = true;
}

/* action handlers */
hitBtn.addEventListener('click', ()=> playerAction('hit'));
standBtn.addEventListener('click', ()=> playerAction('stand'));
doubleBtn.addEventListener('click', ()=> playerAction('double'));
splitBtn.addEventListener('click', ()=> playerAction('split'));
insureBtn.addEventListener('click', ()=> playerAction('insure'));

function playerAction(type){
  const p = players[currentPlayerIdx];
  const h = p.currentHand();
  if(!h) return;
  if(type==='hit'){
    const c = deck.draw(); h.add(c);
    log(`${p.name} zieht ${c.rank}${c.suit} â†’ ${h.value}`);
    playUrl(SOUND_CARD);
    if(h.busted){ log(`${p.name} busted!`); playTone(120,0.12,0.06); }
    renderHands();
    if(h.busted || h.stand || h.blackjack) { setTimeout(()=> advanceTurn(), 650); }
  } else if(type==='stand'){
    h.stand = true;
    log(`${p.name} steht mit ${h.value}`);
    advanceTurn();
  } else if(type==='double'){
    if(h.cards.length !== 2) { log('Double nur auf ersten 2 Karten erlaubt'); return; }
    if(p.bank < h.bet){ log('Nicht genug Guthaben zum Verdoppeln'); return; }
    p.bank -= h.bet; h.bet *= 2; h.doubled = true;
    const c = deck.draw(); h.add(c); h.stand=true;
    log(`${p.name} verdoppelt und zieht ${c.rank}${c.suit} â†’ ${h.value}`);
    renderHands(); updateBankInfo(); playUrl(SOUND_CHIP);
    setTimeout(()=> advanceTurn(), 600);
  } else if(type==='split'){
    if(h.cards.length !== 2 || h.cards[0].rank !== h.cards[1].rank){ log('Split nur bei Paaren'); return; }
    if(p.bank < h.bet){ log('Nicht genug Guthaben fÃ¼r Split'); return; }
    p.bank -= h.bet;
    const card2 = h.cards.pop(); h.recalc();
    const newHand = p.createHand(h.bet);
    newHand.add(card2);
    // draw one card for each hand
    h.add(deck.draw()); newHand.add(deck.draw());
    log(`${p.name} splitet. Zwei HÃ¤nde mit je ${h.bet}â‚¬`);
    renderHands(); updateBankInfo(); playUrl(SOUND_CHIP);
  } else if(type==='insure'){
    const dUp = dealer.hands[0].cards[0];
    if(!dUp || dUp.rank !== 'A'){ log('Insurance nur mÃ¶glich, wenn Dealer Ass zeigt'); return; }
    if(p.bank < Math.ceil(h.bet/2)){ log('Nicht genug Guthaben fÃ¼r Insurance'); return; }
    p.bank -= Math.ceil(h.bet/2);
    h.insured = true;
    log(`${p.name} kauft Insurance fÃ¼r ${Math.ceil(h.bet/2)}â‚¬`);
    updateBankInfo();
  }
  enableActionButtonsForCurrent();
}

/* advance turn to next player or to dealer */
function advanceTurn(){
  const p = players[currentPlayerIdx];
  // try to advance within player's split hands
  if(p.nextHand()){
    renderHands();
    enableActionButtonsForCurrent();
    if(p.type==='bot') setTimeout(()=> processCurrentIfBot(), 400);
    return;
  }
  // else move to next player
  let moved=false;
  for(let i=1;i<=players.length;i++){
    const ni = (currentPlayerIdx + i) % players.length;
    const np = players[ni];
    const hasPending = np.hands.some(h=>!h.stand && !h.busted && !h.blackjack);
    if(hasPending){
      currentPlayerIdx = ni; moved=true; break;
    }
  }
  if(!moved){
    // all players done -> dealer plays
    setTimeout(()=> dealerPlay(), 400);
    return;
  }
  renderHands();
  enableActionButtonsForCurrent();
  if(players[currentPlayerIdx].type === 'bot') setTimeout(()=> processCurrentIfBot(), 450);
}

/* bot play logic (improved heuristic) */
function processCurrentIfBot(){
  const p = players[currentPlayerIdx];
  if(!p || p.type !== 'bot') return;
  const h = p.currentHand();
  if(!h) { advanceTurn(); return; }
  // if can split common strategy for A and 8
  if(h.cards.length===2 && h.cards[0].rank===h.cards[1].rank){
    if(h.cards[0].rank==='A' || h.cards[0].rank==='8'){ log(`${p.name} (Bot) entscheidet: Split`); playerActionFor(p,'split'); return; }
  }
  // double on 9-11 often
  if(h.cards.length===2 && (h.value===9 || h.value===10 || h.value===11) && p.bank >= h.bet){
    if(Math.random() < 0.6){ log(`${p.name} (Bot) entscheidet: Double`); playerActionFor(p,'double'); return; }
  }
  // hit/stand rules similar to basic strategy
  const dealerUp = dealer.hands[0].cards[0];
  const dealerUpVal = cardValueForStrategy(dealerUp);
  if(h.value <= 11){ log(`${p.name} (Bot) zieht`); playerActionFor(p,'hit'); return; }
  if(h.value >= 17){ log(`${p.name} (Bot) steht`); playerActionFor(p,'stand'); return; }
  if(h.value >= 12 && h.value <= 16){
    if(dealerUpVal >=2 && dealerUpVal <=6){ log(`${p.name} (Bot) steht (Dealer schwach)`); playerActionFor(p,'stand'); return; }
    else { log(`${p.name} (Bot) zieht (Dealer stark)`); playerActionFor(p,'hit'); return; }
  }
  // fallback
  playerActionFor(p,'stand');
}

/* helper used by bot to route action to specific player object */
function playerActionFor(playerObj, type){
  const idx = players.indexOf(playerObj);
  const prevIdx = currentPlayerIdx;
  currentPlayerIdx = idx;
  renderHands();
  playerAction(type);
  // restore current if moved
  // after action the functions advanceTurn will move index; no need to revert
}

/* small mapping for bot strategy */
function cardValueForStrategy(card){
  if(!card) return 0;
  if(card.rank==='A') return 11;
  if(['J','Q','K'].includes(card.rank)) return 10;
  return parseInt(card.rank,10);
}

/* dealer play */
function dealerPlay(){
  dealer.revealed = true;
  renderDealer();
  log('Dealer spielt...');
  const hand = dealer.hands[0];
  hand.recalc();
  if(hand.blackjack){
    log('Dealer hat Blackjack!');
    setTimeout(()=> finalizeRound(), 700);
    return;
  }
  const step = ()=>{
    hand.recalc();
    if(hand.value < 17){
      const c = deck.draw(); hand.add(c);
      log(`Dealer zieht ${c.rank}${c.suit} â†’ ${hand.value}`);
      renderDealer(); playUrl(SOUND_CARD);
      setTimeout(step, 700);
    } else {
      log(`Dealer steht mit ${hand.value}`);
      renderDealer();
      setTimeout(()=> finalizeRound(), 600);
    }
  };
  setTimeout(step, 700);
}

/* finalize round: compare hands and payouts */
function finalizeRound(){
  const dHand = dealer.hands[0];
  dHand.recalc();
  const dVal = dHand.value;
  const dBJ = dHand.blackjack;
  log('--- Ergebnis ---');
  for(const p of players){
    for(const h of p.hands){
      if(h.busted){
        log(`${p.name} verliert (${h.bet}â‚¬) â€” busted`);
        continue;
      }
      // insurance
      if(h.insured){
        if(dBJ){
          const pay = Math.ceil(h.bet/2) * 2;
          p.bank += pay;
          log(`${p.name} bekommt Insurance payout ${pay}â‚¬`);
        } else {
          log(`${p.name} verliert Insurance.`);
        }
      }
      // blackjack
      if(h.blackjack && !dBJ){
        const payout = Math.round(h.bet * 2.5);
        p.bank += payout;
        log(`${p.name} Blackjack! Auszahlung ${payout}â‚¬`);
        playUrl(SOUND_WIN);
        continue;
      }
      if(h.blackjack && dBJ){
        p.bank += h.bet;
        log(`${p.name} Push (beide Blackjack). Einsatz zurÃ¼ck.`);
        continue;
      }
      if(dHand.busted){
        p.bank += h.bet * 2;
        log(`${p.name} gewinnt (Dealer busted). Auszahlung ${h.bet*2}â‚¬`);
        playUrl(SOUND_WIN);
        continue;
      }
      if(h.value > dVal){
        p.bank += h.bet * 2;
        log(`${p.name} gewinnt (${h.value} vs ${dVal}). Auszahlung ${h.bet*2}â‚¬`);
        playUrl(SOUND_WIN);
      } else if(h.value === dVal){
        p.bank += h.bet;
        log(`${p.name} Push (${h.value}). Einsatz zurÃ¼ck.`);
      } else {
        log(`${p.name} verliert (${h.value} vs ${dVal}).`);
      }
    }
  }
  inRound = false;
  $('dealBtn').disabled = false;
  disableAllActions();
  renderHands();
  updateBankInfo();
  // show sidebar (setup) again after short delay so user can change settings
  setTimeout(()=> hideSetup(false), 800);
}

/* utility: update bank HUD */
function updateBankInfo(){
  bankInfoEl.textContent = players.map(p=> `${p.name}: ${p.bank}â‚¬`).join('  â€¢  ');
}

/* mute toggle */
muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
});

/* reset page */
$('resetBtn').addEventListener('click', ()=> location.reload());

/* keyboard shortcuts */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'h') hitBtn.click();
  if(e.key === 's') standBtn.click();
});

/* small startup */
log('Blackjack Round Table geladen. Erzeuge Setup und starte das Spiel.');
</script>
</body>
</html>
